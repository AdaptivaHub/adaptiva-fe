/**
 * Charts Page - Chart generation and gallery
 * 
 * Uses the unified chart architecture with ChartGallery:
 * - AI suggests ChartSpec via /api/charts/suggest
 * - ChartSpec is rendered via /api/charts/render
 * - Charts are stored and displayed in ChartGallery
 */

import { useCallback, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useFileStore, useChartStore } from '@/stores';
import { useChart } from '@/hooks/api';
import { Button } from '@design/components/ui/button';
import { EmptyState } from '@design/components/EmptyState';
import { ChartGallery } from '@design/components/charts/ChartGallery';
import type { ChartCreationConfig, ChartConfig } from '@design/components/charts/ChartCreator';
import type { PlotlyJson } from '@design/components/charts/PlotlyChartRenderer';
import { Upload } from 'lucide-react';
import { toast } from 'sonner';

export function ChartsPage() {
  const navigate = useNavigate();
  
  // File store
  const metadata = useFileStore((state) => state.metadata);
  const fileData = useFileStore((state) => state.data);
  const headers = useFileStore((state) => state.headers);
  const hasFile = metadata !== null;

  // Chart store
  const charts = useChartStore((state) => state.charts);
  const viewMode = useChartStore((state) => state.viewMode);
  const isCreating = useChartStore((state) => state.isCreating);
  const editingChart = useChartStore((state) => state.editingChart);
  const addChart = useChartStore((state) => state.addChart);
  const deleteChart = useChartStore((state) => state.deleteChart);
  const setCreating = useChartStore((state) => state.setCreating);
  const setEditing = useChartStore((state) => state.setEditing);
  const setViewMode = useChartStore((state) => state.setViewMode);

  // AI chart hook
  const { 
    spec,
    chartJson,
    suggesting,
    loading,
    error,
    suggest,
    render,
    reset,
  } = useChart();

  const isGenerating = suggesting || loading;
  
  // Track the current AI prompt for chart creation
  const pendingPromptRef = useRef<string | null>(null);

  // Auto-render when spec changes (from AI suggestion)
  useEffect(() => {
    if (spec) {
      render(spec);
    }
  }, [spec, render]);

  // When chartJson is ready from AI, create the chart
  useEffect(() => {
    if (chartJson && pendingPromptRef.current !== null && !suggesting && !loading) {
      const prompt = pendingPromptRef.current;
      pendingPromptRef.current = null;
        // Safely convert chartJson to PlotlyJson
      const plotlyJson: PlotlyJson = {
        data: ((chartJson as { data?: unknown[] }).data || []) as PlotlyJson['data'],
        layout: (chartJson as { layout?: Record<string, unknown> }).layout,
        config: (chartJson as { config?: Record<string, unknown> }).config,
      };
      
      const newChart: ChartConfig = {
        id: crypto.randomUUID(),
        title: prompt.slice(0, 50) || 'AI Generated Chart',
        type: spec?.chart_type || 'bar',
        xAxis: spec?.x_axis?.column,
        yAxis: spec?.y_axis?.columns?.[0],
        data: fileData,
        prompt: prompt,
        createdAt: new Date(),
        plotlyJson: plotlyJson,
      };
      
      addChart(newChart);
      setCreating(false);
      reset();
      toast.success('AI chart generated successfully!');
    }
  }, [chartJson, suggesting, loading, spec, fileData, addChart, setCreating, reset]);

  // Handle manual chart creation
  const handleChartCreated = useCallback((config: ChartCreationConfig, data: Record<string, unknown>[]) => {
    const newChart: ChartConfig = {
      id: crypto.randomUUID(),
      title: config.title,
      type: config.type,
      xAxis: config.xAxis,
      yAxis: config.yAxis,
      data: data,
      prompt: config.prompt,
      createdAt: new Date(),
      plotlyJson: null, // Will be generated by ChartPreview
    };
    
    addChart(newChart);
    setCreating(false);
    toast.success('Chart created successfully!');
  }, [addChart, setCreating]);
  // Handle AI chart generation
  const handleAIGenerate = useCallback(async (prompt: string, _config: ChartCreationConfig) => {
    if (!metadata?.fileId) {
      toast.error('No file loaded');
      return;
    }

    // Store the prompt for when the chart is ready
    pendingPromptRef.current = prompt;

    // Call AI suggest
    const suggestSuccess = await suggest(
      metadata.fileId,
      prompt,
      metadata.activeSheet
    );

    if (!suggestSuccess) {
      pendingPromptRef.current = null;
      toast.error(error || 'Failed to generate chart suggestion');
    }
  }, [metadata, suggest, error]);

  // Handle delete with confirmation
  const handleDeleteChart = useCallback((id: string) => {
    if (window.confirm('Are you sure you want to delete this chart?')) {
      deleteChart(id);
      toast.success('Chart deleted');
    }
  }, [deleteChart]);

  // Handle edit
  const handleEditChart = useCallback((chart: ChartConfig) => {
    setEditing(chart);
  }, [setEditing]);

  // Handle duplicate
  const handleDuplicateChart = useCallback((chart: ChartConfig) => {
    const duplicated: ChartConfig = {
      ...chart,
      id: crypto.randomUUID(),
      title: `${chart.title} (Copy)`,
      createdAt: new Date(),
    };
    addChart(duplicated);
    toast.success('Chart duplicated');
  }, [addChart]);

  // Handle export single chart
  const handleExportChart = useCallback((chart: ChartConfig) => {
    // Export as JSON
    const blob = new Blob([JSON.stringify(chart, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${chart.title.replace(/[^a-z0-9]/gi, '_')}.json`;
    a.click();
    URL.revokeObjectURL(url);
    toast.success('Chart exported');
  }, []);

  // Handle export all charts
  const handleExportAll = useCallback(() => {
    const blob = new Blob([JSON.stringify(charts, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'all_charts.json';
    a.click();
    URL.revokeObjectURL(url);
    toast.success('All charts exported');
  }, [charts]);

  // Handle fullscreen (placeholder - could open modal)
  const handleFullscreenChart = useCallback((chart: ChartConfig) => {
    // TODO: Implement fullscreen modal
    toast.info(`Fullscreen view for "${chart.title}" - coming soon!`);
  }, []);

  // No file uploaded
  if (!hasFile) {
    return (
      <div className="p-6">
        <EmptyState
          icon={<Upload className="w-12 h-12" />}
          title="No Data Available"
          description="Upload a file first to create charts and visualizations."
          action={
            <Button
              onClick={() => navigate('/upload')}
              className="bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700"
            >
              <Upload className="w-4 h-4 mr-2" />
              Upload File
            </Button>
          }
        />
      </div>
    );
  }

  return (
    <div className="p-6">
      <ChartGallery
        headers={headers}
        data={fileData}
        charts={charts}
        viewMode={viewMode}
        showCreator={isCreating}
        editingChart={editingChart}
        isGenerating={isGenerating}
        onViewModeChange={setViewMode}
        onCreateClick={() => setCreating(true)}
        onChartCreated={handleChartCreated}
        onAIGenerate={handleAIGenerate}
        onDeleteChart={handleDeleteChart}
        onEditChart={handleEditChart}
        onExportChart={handleExportChart}
        onDuplicateChart={handleDuplicateChart}
        onFullscreenChart={handleFullscreenChart}
        onCloseCreator={() => {
          setCreating(false);
          setEditing(null);
        }}        onExportAll={handleExportAll}
      />
    </div>
  );
}
